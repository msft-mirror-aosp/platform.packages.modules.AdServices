/*
 * Copyright (C) 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.cobalt.observations;

import static com.google.common.truth.Truth.assertThat;

import androidx.test.runner.AndroidJUnit4;

import com.android.cobalt.data.EventRecordAndSystemProfile;
import com.android.cobalt.data.EventVector;
import com.android.cobalt.system.SystemData;
import com.android.cobalt.testing.logging.FakeCobaltOperationLogger;
import com.android.cobalt.testing.observations.FakeSecureRandom;
import com.android.cobalt.testing.observations.ObservationFactory;

import com.google.cobalt.AggregateValue;
import com.google.cobalt.MetricDefinition;
import com.google.cobalt.MetricDefinition.MetricDimension;
import com.google.cobalt.MetricDefinition.MetricType;
import com.google.cobalt.MetricDefinition.TimeZonePolicy;
import com.google.cobalt.ObservationMetadata;
import com.google.cobalt.ReportDefinition;
import com.google.cobalt.ReportDefinition.PrivacyMechanism;
import com.google.cobalt.ReportDefinition.ReportType;
import com.google.cobalt.ReportDefinition.ShuffledDifferentialPrivacyConfig;
import com.google.cobalt.SystemProfile;
import com.google.cobalt.SystemProfileField;
import com.google.cobalt.UnencryptedObservationBatch;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableListMultimap;
import com.google.protobuf.ByteString;

import org.junit.Test;
import org.junit.runner.RunWith;

import java.security.SecureRandom;
import java.util.List;

@RunWith(AndroidJUnit4.class)
public final class PrivateObservationGeneratorTest {
    private static final int DAY_INDEX = 19201; // 2022-07-28
    private static final int CUSTOMER = 1;
    private static final int PROJECT = 2;
    private static final int METRIC_ID = 3;
    private static final int REPORT_ID = 4;
    private static final SystemProfile SYSTEM_PROFILE_1 =
            SystemProfile.newBuilder().setAppVersion("1.2.3").build();
    private static final SystemProfile SYSTEM_PROFILE_2 =
            SystemProfile.newBuilder().setAppVersion("2.4.8").build();
    private static final ObservationMetadata METADATA_1 =
            ObservationMetadata.newBuilder()
                    .setCustomerId(CUSTOMER)
                    .setProjectId(PROJECT)
                    .setMetricId(METRIC_ID)
                    .setReportId(REPORT_ID)
                    .setDayIndex(DAY_INDEX)
                    .setSystemProfile(SYSTEM_PROFILE_1)
                    .build();
    private static final ObservationMetadata METADATA_2 =
            ObservationMetadata.newBuilder()
                    .setCustomerId(CUSTOMER)
                    .setProjectId(PROJECT)
                    .setMetricId(METRIC_ID)
                    .setReportId(REPORT_ID)
                    .setDayIndex(DAY_INDEX)
                    .setSystemProfile(SYSTEM_PROFILE_2)
                    .build();
    private static final int EVENT_COUNT_1 = 3;
    private static final int EVENT_COUNT_2 = 17;
    private static final EventVector EVENT_VECTOR_1 = EventVector.create(ImmutableList.of(1, 5));
    private static final EventVector EVENT_VECTOR_2 = EventVector.create(ImmutableList.of(2, 6));
    private static final EventRecordAndSystemProfile EVENT_1 =
            createEvent(EVENT_VECTOR_1, EVENT_COUNT_1);
    private static final EventRecordAndSystemProfile EVENT_2 =
            createEvent(EVENT_VECTOR_2, EVENT_COUNT_2);

    // Deterministic randomly generated bytes due to the FakeSecureRandom.
    private static final ByteString RANDOM_BYTES_1 =
            ByteString.copyFrom(new byte[] {0, 0, 0, 0, 0, 0, 0, 0});
    private static final ByteString RANDOM_BYTES_2 =
            ByteString.copyFrom(new byte[] {1, 1, 1, 1, 1, 1, 1, 1});
    private static final ByteString RANDOM_BYTES_3 =
            ByteString.copyFrom(new byte[] {2, 2, 2, 2, 2, 2, 2, 2});
    private static final ByteString RANDOM_BYTES_4 =
            ByteString.copyFrom(new byte[] {3, 3, 3, 3, 3, 3, 3, 3});

    private static final MetricDefinition METRIC =
            MetricDefinition.newBuilder()
                    .setId(METRIC_ID)
                    .setMetricType(MetricType.OCCURRENCE)
                    .setTimeZonePolicy(TimeZonePolicy.OTHER_TIME_ZONE)
                    .setOtherTimeZone("America/Los_Angeles")
                    .build();
    private static final MetricDefinition METRIC_WITH_DIMENSIONs =
            MetricDefinition.newBuilder()
                    .setId(METRIC_ID)
                    .setMetricType(MetricType.OCCURRENCE)
                    .setTimeZonePolicy(TimeZonePolicy.OTHER_TIME_ZONE)
                    .setOtherTimeZone("America/Los_Angeles")
                    .addMetricDimensions(MetricDimension.newBuilder().setMaxEventCode(2))
                    .addMetricDimensions(
                            MetricDimension.newBuilder()
                                    .putEventCodes(5, "5")
                                    .putEventCodes(6, "6"))
                    .build();
    private static final ReportDefinition REPORT =
            ReportDefinition.newBuilder()
                    .setId(REPORT_ID)
                    .setReportType(ReportType.FLEETWIDE_OCCURRENCE_COUNTS)
                    .addSystemProfileField(SystemProfileField.APP_VERSION)
                    .setPrivacyMechanism(PrivacyMechanism.SHUFFLED_DIFFERENTIAL_PRIVACY)
                    // Use a poisson mean that will not produce a fabricated observation.
                    // The FakeSecureRandom will generate a fabricated observation for lamba > 0.1.
                    // Lambda is calculated by `poissonMean*(maxIndex+1)`, with maxIndex for a
                    // report equal to `(maxEventVector+1)*numIndexPoints-1`.  For this defined
                    // report with metric dimensions lambda = poissonMean*(((5+1)*11-1)+1) =
                    // poissonMean*66, which requires that poissonMean < 0.0015 to ensure no
                    // fabricated observations.
                    .setShuffledDp(
                            ShuffledDifferentialPrivacyConfig.newBuilder().setPoissonMean(0.001))
                    .setNumIndexPoints(11)
                    .setMinValue(0)
                    .setMaxValue(20)
                    .build();

    private final SecureRandom mSecureRandom;
    private final PrivacyGenerator mPrivacyGenerator;
    private FakeCobaltOperationLogger mOperationLogger;
    private PrivateObservationGenerator mGenerator;

    public PrivateObservationGeneratorTest() {
        mSecureRandom = new FakeSecureRandom();
        mPrivacyGenerator = new PrivacyGenerator(mSecureRandom);
        mOperationLogger = new FakeCobaltOperationLogger();
        mGenerator = null;
    }

    private PrivateObservationGenerator createObservationGenerator(
            int customerId, int projectId, MetricDefinition metric, ReportDefinition report) {
        return new PrivateObservationGenerator(
                new SystemData(SYSTEM_PROFILE_1.getAppVersion()),
                mPrivacyGenerator,
                mSecureRandom,
                new PrivateIntegerEncoder(mSecureRandom, metric, report, mOperationLogger),
                mOperationLogger,
                customerId,
                projectId,
                metric,
                report);
    }

    private static EventRecordAndSystemProfile createEvent(
            List<Integer> eventCodes, int aggregateValue) {
        // System profile fields are ignored during observation generation and can be anything.
        return EventRecordAndSystemProfile.create(
                /* systemProfile= */ SystemProfile.getDefaultInstance(),
                EventVector.create(eventCodes),
                AggregateValue.newBuilder().setIntegerValue(aggregateValue).build());
    }

    private static EventRecordAndSystemProfile createEvent(
            EventVector eventVector, int aggregateValue) {
        // System profile fields are ignored during observation generation and can be anything.
        return EventRecordAndSystemProfile.create(
                /* systemProfile= */ SystemProfile.getDefaultInstance(),
                eventVector,
                AggregateValue.newBuilder().setIntegerValue(aggregateValue).build());
    }

    @Test
    public void testGenerateObservations_noEvents_reportParticipationOnly() throws Exception {
        mGenerator = createObservationGenerator(CUSTOMER, PROJECT, METRIC, REPORT);
        List<UnencryptedObservationBatch> result =
                mGenerator.generateObservations(DAY_INDEX, ImmutableListMultimap.of());

        // Only a report participation observation is expected, as the report's lambda is too small
        // to trigger a fabricated observation.
        assertThat(result).hasSize(1);
        // Used the current system's SystemProfile, as no logged events have system profiles.
        assertThat(result.get(0).getMetadata()).isEqualTo(METADATA_1);
        assertThat(result.get(0).getUnencryptedObservationsList()).hasSize(1);
        assertThat(result.get(0).getUnencryptedObservations(0).getContributionId())
                .isEqualTo(RANDOM_BYTES_2);
        assertThat(result.get(0).getUnencryptedObservations(0).getObservation())
                .isEqualTo(ObservationFactory.createReportParticipationObservation(RANDOM_BYTES_1));
    }

    @Test
    public void testGenerateObservations_noEventsButFabricatedObservation_twoObservations()
            throws Exception {
        mGenerator =
                createObservationGenerator(
                        // Use a larger Poisson mean that is guaranteed to cause a fabricated
                        // observation to be created, due to the FakeSecureRandom implementation.
                        // lambda = poissonMean*((((maxEventVectorIndex+1)*numIndexPoints)-1)+1)
                        //        = poissonMean*((((0+1)*11)-1)+1) = poissonMean*11 >= 0.1
                        // poissonMean >= 0.0091
                        CUSTOMER,
                        PROJECT,
                        METRIC,
                        REPORT.toBuilder()
                                .setShuffledDp(
                                        ShuffledDifferentialPrivacyConfig.newBuilder()
                                                .setPoissonMean(0.01))
                                .build());
        List<UnencryptedObservationBatch> result =
                mGenerator.generateObservations(DAY_INDEX, ImmutableListMultimap.of());

        // A fabricated observation and a report participation observation are expected in one
        // batch.
        assertThat(result).hasSize(1);
        // Used the current system's SystemProfile, as no logged events have system profiles.
        assertThat(result.get(0).getMetadata()).isEqualTo(METADATA_1);
        assertThat(result.get(0).getUnencryptedObservationsList()).hasSize(2);
        assertThat(result.get(0).getUnencryptedObservations(0).getContributionId())
                .isEqualTo(RANDOM_BYTES_3);
        assertThat(result.get(0).getUnencryptedObservations(0).getObservation())
                .isEqualTo(
                        // Fabricated observations use
                        // `sampleUniformDistribution(maxIndex)`to choose the index, with
                        // FakeSecureRandom returning decrementing values starting at the
                        // max. Max index is 1 event vectors * 11 numIndexPoints - 1 = 10
                        ObservationFactory.createPrivateIndexObservation(
                                /* privateIndex= */ 10, RANDOM_BYTES_1));
        assertThat(result.get(0).getUnencryptedObservations(1).getContributionId()).isEmpty();
        assertThat(result.get(0).getUnencryptedObservations(1).getObservation())
                .isEqualTo(ObservationFactory.createReportParticipationObservation(RANDOM_BYTES_2));
    }

    @Test
    public void testGenerateObservations_oneEvent_generatedPlusReportParticipation()
            throws Exception {
        mGenerator = createObservationGenerator(CUSTOMER, PROJECT, METRIC, REPORT);
        List<UnencryptedObservationBatch> result =
                mGenerator.generateObservations(
                        DAY_INDEX,
                        ImmutableListMultimap.of(
                                SYSTEM_PROFILE_2, createEvent(ImmutableList.of(), 11)));

        // A real and a report participation observation is expected, as the report's lambda is too
        // small to trigger a fabricated observation.
        assertThat(result).hasSize(1);
        // All observations use the logged system profile.
        assertThat(result.get(0).getMetadata()).isEqualTo(METADATA_2);
        assertThat(result.get(0).getUnencryptedObservationsList()).hasSize(2);
        assertThat(result.get(0).getUnencryptedObservations(0).getContributionId())
                .isEqualTo(RANDOM_BYTES_3);
        assertThat(result.get(0).getUnencryptedObservations(0).getObservation())
                .isEqualTo(
                        // Value 11 has index 5
                        ObservationFactory.createPrivateIndexObservation(
                                /* privateIndex= */ 5, RANDOM_BYTES_1));
        assertThat(result.get(0).getUnencryptedObservations(1).getContributionId()).isEmpty();
        assertThat(result.get(0).getUnencryptedObservations(1).getObservation())
                .isEqualTo(ObservationFactory.createReportParticipationObservation(RANDOM_BYTES_2));
    }

    @Test
    public void testGenerateObservations_oneEventAndFabricatedObservation_threeObservations()
            throws Exception {
        mGenerator =
                createObservationGenerator(
                        // Use a larger Poisson mean that is guaranteed to cause a fabricated
                        // observation to be created, due to the FakeSecureRandom implementation
                        // that generates a fabricated observation for lambda >= 0.1.
                        // lambda = poissonMean*((((maxEventVectorIndex+1)*numIndexPoints)-1)+1)
                        //        = poissonMean*((((0+1)*11)-1)+1) = poissonMean*11 >= 0.1
                        // poissonMean >= 0.0091
                        CUSTOMER,
                        PROJECT,
                        METRIC,
                        REPORT.toBuilder()
                                .setShuffledDp(
                                        ShuffledDifferentialPrivacyConfig.newBuilder()
                                                .setPoissonMean(0.01))
                                .build());
        List<UnencryptedObservationBatch> result =
                mGenerator.generateObservations(
                        DAY_INDEX,
                        ImmutableListMultimap.of(
                                SYSTEM_PROFILE_2, createEvent(ImmutableList.of(), 13)));

        // A real, a fabricated, and a report participation observation are expected, all in one
        // batch.
        assertThat(result).hasSize(1);
        // All observations use the logged system profile.
        assertThat(result.get(0).getMetadata()).isEqualTo(METADATA_2);
        assertThat(result.get(0).getUnencryptedObservationsList()).hasSize(3);
        assertThat(result.get(0).getUnencryptedObservations(0).getContributionId())
                .isEqualTo(RANDOM_BYTES_4);
        assertThat(result.get(0).getUnencryptedObservations(0).getObservation())
                .isEqualTo(
                        // Value 13 has index 6.
                        ObservationFactory.createPrivateIndexObservation(
                                /* privateIndex= */ 6, RANDOM_BYTES_1));
        assertThat(result.get(0).getUnencryptedObservations(1).getContributionId()).isEmpty();
        assertThat(result.get(0).getUnencryptedObservations(1).getObservation())
                .isEqualTo(
                        // Max index is 1 event vectors * 11 numIndexPoints - 1 = 10
                        ObservationFactory.createPrivateIndexObservation(
                                /* privateIndex= */ 10, RANDOM_BYTES_2));
        assertThat(result.get(0).getUnencryptedObservations(2).getContributionId()).isEmpty();
        assertThat(result.get(0).getUnencryptedObservations(2).getObservation())
                .isEqualTo(ObservationFactory.createReportParticipationObservation(RANDOM_BYTES_3));
    }

    @Test
    public void testGenerateObservations_oneEventForMetricWithDimensions_threeObservations()
            throws Exception {
        mGenerator =
                createObservationGenerator(
                        CUSTOMER,
                        PROJECT,
                        METRIC_WITH_DIMENSIONs,
                        // Use a larger Poisson mean that is guaranteed to cause a single fabricated
                        // observation to be created, due to the FakeSecureRandom implementation.
                        // This is smaller than other tests, because the poisson mean is multiplied
                        // by the number of indices, which is larger here due the metric dimensions.
                        // lambda = poissonMean*((((maxEventVectorIndex+1)*numIndexPoints)-1)+1)
                        //        = poissonMean*((((5+1)*11)-1)+1) = poissonMean*66 >= 0.1
                        // poissonMean >= 0.00152
                        REPORT.toBuilder()
                                .setShuffledDp(
                                        ShuffledDifferentialPrivacyConfig.newBuilder()
                                                .setPoissonMean(0.002))
                                .build());
        List<UnencryptedObservationBatch> result =
                mGenerator.generateObservations(
                        DAY_INDEX, ImmutableListMultimap.of(SYSTEM_PROFILE_2, EVENT_1));

        // A real, a fabricated, and a report participation observation are expected, all in one
        // batch.
        assertThat(result).hasSize(1);
        // All observations use the logged system profile.
        assertThat(result.get(0).getMetadata()).isEqualTo(METADATA_2);
        assertThat(result.get(0).getUnencryptedObservationsList()).hasSize(3);
        assertThat(result.get(0).getUnencryptedObservations(0).getContributionId())
                .isEqualTo(RANDOM_BYTES_4);
        assertThat(result.get(0).getUnencryptedObservations(0).getObservation())
                .isEqualTo(
                        // Event vector (1,5) is index 1. Index 0 is (0,5). Max event vector
                        // index is 5. Value 3 is Index 1.  The combined index is 7.
                        ObservationFactory.createPrivateIndexObservation(
                                /* privateIndex= */ 7, RANDOM_BYTES_1));
        assertThat(result.get(0).getUnencryptedObservations(1).getContributionId()).isEmpty();
        assertThat(result.get(0).getUnencryptedObservations(1).getObservation())
                .isEqualTo(
                        // Max index is 6 event vectors * 11 numIndexPoints - 1 = 65
                        ObservationFactory.createPrivateIndexObservation(
                                /* privateIndex= */ 65, RANDOM_BYTES_2));
        assertThat(result.get(0).getUnencryptedObservations(2).getContributionId()).isEmpty();
        assertThat(result.get(0).getUnencryptedObservations(2).getObservation())
                .isEqualTo(ObservationFactory.createReportParticipationObservation(RANDOM_BYTES_3));
    }

    @Test
    public void
            testGenerateObservations_eventVectorBufferMaxLimit_eventVectorBufferMaxExceededLogged()
                    throws Exception {
        mGenerator =
                createObservationGenerator(
                        CUSTOMER,
                        PROJECT,
                        METRIC_WITH_DIMENSIONs,
                        REPORT.toBuilder()
                                .setShuffledDp(
                                        ShuffledDifferentialPrivacyConfig.newBuilder()
                                                .setPoissonMean(0.002))
                                .setEventVectorBufferMax(1)
                                .build());
        mGenerator.generateObservations(
                DAY_INDEX,
                ImmutableListMultimap.of(SYSTEM_PROFILE_1, EVENT_1, SYSTEM_PROFILE_1, EVENT_2));

        // Check that it was recorded that event vector buffer max was exceeded for the metric id
        // and report id.
        assertThat(
                        mOperationLogger.getNumEventVectorBufferMaxExceededOccurrences(
                                METRIC_ID, REPORT_ID))
                .isEqualTo(1);
    }

    @Test
    public void
            testGenerateObservations_underEventVectorBufferMaxLimit_noEventVectorBufferMaxExceededLogged()
                    throws Exception {
        mGenerator =
                createObservationGenerator(
                        CUSTOMER,
                        PROJECT,
                        METRIC_WITH_DIMENSIONs,
                        REPORT.toBuilder()
                                .setShuffledDp(
                                        ShuffledDifferentialPrivacyConfig.newBuilder()
                                                .setPoissonMean(0.002))
                                .setEventVectorBufferMax(1)
                                .build());
        mGenerator.generateObservations(
                DAY_INDEX,
                ImmutableListMultimap.of(SYSTEM_PROFILE_1, EVENT_1, SYSTEM_PROFILE_2, EVENT_2));

        // Check that it was recorded that event vector buffer max was exceeded for the metric id
        // and report id.
        assertThat(
                        mOperationLogger.getNumEventVectorBufferMaxExceededOccurrences(
                                METRIC_ID, REPORT_ID))
                .isEqualTo(0);
    }
}
