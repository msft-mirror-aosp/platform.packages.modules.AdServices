/*
 * Copyright (C) 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.adservices.ohttp;

import android.annotation.NonNull;

import com.android.adservices.ohttp.algorithms.AeadAlgorithmSpec;
import com.android.adservices.ohttp.algorithms.KdfAlgorithmSpec;
import com.android.adservices.ohttp.algorithms.KemAlgorithmSpec;
import com.android.adservices.ohttp.algorithms.UnsupportedHpkeAlgorithmException;

import com.google.common.base.Preconditions;

import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;

/** Provides methods for OHTTP server/gateway side encryption and decryption */
public class ObliviousHttpGateway {
    private static final String OHTTP_REQUEST_LABEL = "message/bhttp request";

    /**
     * According to https://www.ietf.org/archive/id/draft-ietf-ohai-ohttp-03.html#section-4.1-6
     *
     * <p>hdr = concat(encode(1, keyID), encode(2, kemID), encode(2, kdfID), encode(2, aeadID))
     *
     * <p>total length = 7 (1+2+2+2)
     */
    private static final int MESSAGE_HEADER_LENGTH_IN_BYTES = 7;

    /**
     * Decrypts the given encapsulated request using the private key provided
     *
     * <p>From https://www.ietf.org/archive/id/draft-ietf-ohai-ohttp-03.html#section-4-4
     *
     * <p>The encapsulated request is a combination of :
     *
     * <pre>     Encapsulated Request {
     *            Key Identifier (8),
     *            KEM Identifier (16),
     *            KDF Identifier (16),
     *            AEAD Identifier (16),
     *            Encapsulated KEM Shared Secret (8*Nenc),
     *            AEAD-Protected Request (..)}
     * </pre>
     *
     * <p>This method provides a way to decrypt payloads generated by {@link
     * ObliviousHttpClient#createObliviousHttpRequest(byte[])}
     *
     * @param privateKey The private key with which to decrypt the payload
     * @param encapsulatedRequest The payload to decrypt.
     * @return the decrypted bytes
     */
    public static byte[] decrypt(
            OhttpGatewayPrivateKey privateKey, @NonNull byte[] encapsulatedRequest)
            throws UnsupportedHpkeAlgorithmException, IOException {

        // Parse the encapsulated request into its components
        int keyId = getKeyId(encapsulatedRequest);
        KemAlgorithmSpec kemAlgorithmSpec = getKem(encapsulatedRequest);
        KdfAlgorithmSpec kdfAlgorithmSpec = getKdf(encapsulatedRequest);
        AeadAlgorithmSpec aeadAlgorithmSpec = getAead(encapsulatedRequest);

        EncapsulatedSharedSecret encapsulatedSharedSecret =
                getEncapsulatedSharedSecret(
                        kemAlgorithmSpec.encapsulatedKeyLength(), encapsulatedRequest);

        // Compute the recipient info required to decrypt the payload
        // As per https://www.ietf.org/archive/id/draft-ietf-ohai-ohttp-03.html#section-4.1-10
        RecipientKeyInfo info =
                createRecipientKeyInfo(
                        keyId,
                        kemAlgorithmSpec.identifier(),
                        kdfAlgorithmSpec.identifier(),
                        aeadAlgorithmSpec.identifier());

        byte[] cipherText =
                getCipherText(kemAlgorithmSpec.encapsulatedKeyLength(), encapsulatedRequest);

        OhttpJniWrapper jniWrapper = OhttpJniWrapper.getInstance();
        GatewayDecryptResponse decrypted =
                jniWrapper.gatewayDecrypt(
                        kemAlgorithmSpec.kemNativeRefSupplier().get(),
                        kdfAlgorithmSpec.kdfNativeRefSupplier().get(),
                        aeadAlgorithmSpec.aeadNativeRefSupplier().get(),
                        privateKey,
                        encapsulatedSharedSecret,
                        info,
                        cipherText);

        return decrypted.getBytes();
    }

    private static int getKeyId(byte[] cipherText) {
        return cipherText[0];
    }

    private static KemAlgorithmSpec getKem(byte[] cipherText)
            throws UnsupportedHpkeAlgorithmException {
        int kemId = ((cipherText[1] & 0xff) << 8) | (cipherText[2] & 0xff);
        return KemAlgorithmSpec.get(kemId);
    }

    private static KdfAlgorithmSpec getKdf(byte[] cipherText)
            throws UnsupportedHpkeAlgorithmException {
        int kdfId = ((cipherText[3] & 0xff) << 8) | (cipherText[4] & 0xff);
        return KdfAlgorithmSpec.get(kdfId);
    }

    private static AeadAlgorithmSpec getAead(byte[] cipherText)
            throws UnsupportedHpkeAlgorithmException {
        int aeadId = ((cipherText[5] & 0xff) << 8) | (cipherText[6] & 0xff);
        return AeadAlgorithmSpec.get(aeadId);
    }

    private static EncapsulatedSharedSecret getEncapsulatedSharedSecret(
            int encLength, byte[] cipherText) {
        Preconditions.checkArgument(
                encLength + MESSAGE_HEADER_LENGTH_IN_BYTES <= cipherText.length);
        byte[] destinationArray = new byte[encLength];
        System.arraycopy(
                cipherText,
                MESSAGE_HEADER_LENGTH_IN_BYTES,
                destinationArray,
                /* destPos= */ 0,
                encLength);
        return EncapsulatedSharedSecret.create(destinationArray);
    }

    /**
     * Generates the 'info' field as required by HPKE setupBaseR operation according to OHTTP spec
     *
     * <p>https://www.ietf.org/archive/id/draft-ietf-ohai-ohttp-03.html#section-4.1-10
     *
     * <pre>info = concat(encode_str("message/bhttp request"),
     *               encode(1, 0),
     *               encode(1, keyID),
     *               encode(2, kemID),
     *               encode(2, kdfID),
     *               encode(2, aeadID)) </pre>
     */
    private static RecipientKeyInfo createRecipientKeyInfo(
            int keyId, int kemId, int kdfId, int aeadId) throws IOException {
        try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
                DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream)) {
            byte[] ohttpReqLabelBytes = OHTTP_REQUEST_LABEL.getBytes(StandardCharsets.US_ASCII);
            dataOutputStream.write(ohttpReqLabelBytes);
            dataOutputStream.writeByte(0);

            // TODO(b/309095970) : Extract OhttpMessageHeader into its own class
            dataOutputStream.writeByte(keyId);
            dataOutputStream.writeShort(kemId);
            dataOutputStream.writeShort(kdfId);
            dataOutputStream.writeShort(aeadId);
            dataOutputStream.flush();

            return RecipientKeyInfo.create(byteArrayOutputStream.toByteArray());
        }
    }

    private static byte[] getCipherText(int encLength, byte[] encapsulatedRequest) {
        Preconditions.checkArgument(
                encLength + MESSAGE_HEADER_LENGTH_IN_BYTES <= encapsulatedRequest.length);
        int sizeOfCipherText =
                encapsulatedRequest.length - (MESSAGE_HEADER_LENGTH_IN_BYTES + encLength);
        byte[] destinationArray = new byte[sizeOfCipherText];
        System.arraycopy(
                encapsulatedRequest,
                /* srcPos= */ encLength + MESSAGE_HEADER_LENGTH_IN_BYTES,
                destinationArray,
                /* destPos= */ 0,
                sizeOfCipherText);
        return destinationArray;
    }
}
